Packets, Connections, and Datagrams

1. 电话网络
   1. 建立环路（是不是电流不好说）
   2. 按环路使用时间+端点来计费,哪怕我们没有传递信息
   3. 提供带宽brandwidth和负载capacity来传递信息
   4. analog roots? 将模拟信号用数字信号提高了性能与可信赖度reliability
2. packet switching （分组交换）
   1. 来自不同的数据源或者发送者的chunks可以混在一起也可以稍后分离开来，称之为multiplexing（复用）
   2. chunks在旅途中可以从不同的switch中跳转，路径可以主动变换，这有两大优势
      1. 变得更耐用，设计者担心网络被人攻击
      2. 更具可用性，由于statistical mutiplexing (统计复用)
   3. 当packet被packet switch收到的时候，通常会放置在buffer或者队列中，以FCFS风格来处理
   4. 在统计复用中，流量基于流量的统计数据(arrival statistics)和时序模式来混合传输
   5. 这种方法的缺点在于可预测性较低——任何特定应用的性能表现，都取决于共享网络的其他应用的流量统计特性。
   6. 统计复用就像一个可以变道的高速，每一时刻的出口都有车出闸
   7. 时分复用（TDM）和静态复用等其他技术通常采用固定资源分配机制，会为每条连接预留特定的时隙或专用带宽资源。但是这样对带宽的利用率肯定是不足的
   8. 电路可以直接通过时分复用（TDM）技术实现，但虚拟电路（VC）——虽具有诸多电路特性却不依赖物理电路交换——可在面向连接的分组网络上实现。
      1. VCs专注于确定性和可靠性，具备高质量的效果
      2. VC这项技术不同于传统的物理依赖却具备多种传统电路的好的特性
      3. X.25协议正是基于这一技术原理，该协议在20世纪90年代初之前曾广为流行，随后逐渐被帧中继（Frame Relay）取代，并最终演进为支持互联网接入的数字用户线（DSL）技术和电缆调制解调器（详见第3章）。
   9. 虚拟电路（VC）抽象层与X.25等面向连接的分组网络要求每个交换机为每条连接保存特定信息或状态。这是因为每个数据包仅携带少量开销信息（作为状态表的索引标识）。例如在X.25中，12比特的逻辑信道标识符（LCI）或逻辑信道号（LCN）就承担了这一功能。每个交换机通过LCI/LCN结合本地存储的流状态信息，确定数据包的下一跳转发路径。
      1. LCI是全局的，相当于快递单
      2. LCN则是像分拣中心内部编号（本地简化：`仓库A-货架3-格子5`）
      3. 当某交换机故障时，只需重新协商LCN
   10. 虚电路（VC）上的每条流状态均需通过**信令协议**预先建立，该协议支持连接创建、拆除及状态信息同步。因此，这类网络被称为**面向连接型网络**。
       1. 但是面向连接并不意味着VC
       2. VC是网络层的技术
       3. TCP是传输层的技术
   11. 长期以来，面向连接的网络（无论基于电路交换还是分组交换）始终是网络技术的主流形式。20世纪60年代末，另一种技术方案应运而生——**数据报（datagram）**。该概念最早可追溯至CYCLADES网络系统[P73]，其本质是一种特殊的分组格式：所有标识信息（包括源地址和最终目的地址）均内嵌于数据报内部（而非存储在分组交换机中）。
       1. 数据报（特殊的packet）在网络层就知道目的地
       2. packet只知道下一条的位置，具体要达到目的地则需要更高层的抽象来处理
       3. 尽管这意味着更长的packet,但是这也意味着无需pre-connection的connectionless网络，省去了复杂的信令协议
   12. 其他相关的概念是消息边界(message boundaries)和record markers (记录标志) ![image-20250507182507617](./assets/image-20250507182507617.png)
       1. 应用程序通过协议传输消息时，消息边界即两次写入操作之间的字节偏移量。
          1. 保留消息边界的协议（如图左侧）会在接收端明确标识发送方的原始消息边界；
          2. 而不保留边界的协议（如TCP等流式协议，如图右侧）则会忽略该信息，接收端无法感知原始消息划分。因此，若需维持消息边界，应用程序需自行实现边界标识机制
          3. 大多数数据报协议会保留消息边界。
       2. 但在电路交换或虚电路（VC）网络中，发送方可能写入多个数据块，接收方却会将其合并为不同大小的数据块一次性读取——这类协议不保留消息边界。**若底层协议无法保留边界而应用又需要该特性时，应用程序必须自行实现边界标识机制。**

The End-to-End Argument and Fate Sharing 

1. 在设计操作系统或协议套件等大型系统时，常需决策特定功能应部署(be placed)在哪个层级。这一问题的核心指导原则是**端到端原则（end-to-end argument）**

   1. The function in question : 当前讨论的功能

   2. 所讨论的功能，唯有借助通信系统端点应用程序的协同参与，方能完整且正确地实现。

      > The function in question can completely and correctly be implemented only with  the knowledge and help of the application standing at the end points of the com munication system. 

   3. 因此，若要将该功能完全交由通信系统原生实现，实不可行。（尽管通信系统提供的部分实现有时可作为性能优化手段。）

      > Therefore, providing that questioned function as a feature of  the communication itself is not possible. (Sometimes an incomplete version of the  function provided by the communication system may be useful as a performance  enhancement.

   4. 简单来说，这个原则就是大系统的重要的功能不应当在低层级实现，尽管后者可以为功能实现减轻负担以及优化性能做出努力

      1. ### Nuanced：源自拉丁语 *"nubes"*（云），隐喻色彩/明暗的渐变层次

         ![image-20250507190049325](./assets/image-20250507190049325.png)

   5. 端到端原则倾向于支持一种设计，即网络本身保持“愚钝”，而连接到网络的系统则更“聪明”。在 TCP/IP 的设计中我们正是看到这种模式，许多功能（例如：确保数据不丢失的方法、控制发送方发送速率的机制）都是在终端主机中实现的，而这些主机运行着具体的应用程序。至于哪些功能应当集中实现于同一台计算机、网络或软件栈中，这是另一个相关设计原则“命运共享”的主题。
   
   6. 命运共享原则建议将维持一个活跃通信关联（例如虚拟连接）所需的全部状态信息，放置在与通信端点相同的位置。
   
      1. **容错性强**：如果网络中的某个路由器或交换机发生故障，不会导致连接状态丢失，因为状态保存在端点；
      2. **与端到端原则一致**：端系统负责关键控制逻辑，网络保持简单。
   
   7. 按照这种推理，唯一会破坏通信的失败类型，是那些同时摧毁一个或多个通信端点的失败，而这类失败显然无论如何都会导致整个通信的终止。
   
   8. 命运共享是这样一种设计理念，它使得虚拟连接（例如由 TCP 实现的连接）即便在网络内部的连接暂时中断（在一个适度的时间范围内）时，仍能保持活跃状态。
   
      1. TCP 的连接状态（如序列号、确认号、重传机制等）是由通信两端各自维护的。这意味着，即使网络中途出现了暂时性故障（例如路由变化、链路中断几秒钟），只要最终路径恢复，通信就能继续进行，不需要重建连接。
   
   9. 命运共享同样支持一种“愚钝的网络，智能的端主机”模型。而在当今的互联网中，关于哪些功能应由网络承担、哪些功能不应由网络承担，始终存在着持续的争论。
   
      1. ongoing tension 不指冲突，而是指长期存在尚未解决的分歧
      2. TCP 的拥塞控制在端主机；
      3. 但一些现代网络（如 MPLS、5G）又倾向将部分控制逻辑下放到网络中（如 QoS、路径优化）；
      4. 中间件如 NAT、防火墙、负载均衡器等也是“智能网络”理念的体现。

Error Control and Flow Control

1. 在某些情况下，网络中的数据会遭到破坏或丢失。这可能由多种原因造成，例如硬件故障、在传输过程中辐射导致比特被修改、处于无线网络的信号覆盖范围之外，以及其他因素。应对这些错误的过程被称为差错控制（error control），它可以在构成网络基础设施的系统中实现，也可以在连接到网络的终端系统中实现，或者两者结合。

2. 应对这些错误的过程被称为差错控制（error control），它可以在构成网络基础设施的系统中实现，也可以在连接到网络的终端系统中实现，或者两者结合。而从端到端原则和命运共享原则来看，自然地，它们会建议将差错控制实现于靠近应用程序的地方，或直接在应用程序中。

   1. 以太网在链路层做了CRC校验，但它只覆盖一跳，无法覆盖整个通信路径
   2. TCP在端到端做了校验和和重传机制，即使中间链路发生错误也能保障通信。

3. 通常情况下，如果只需关注少量比特错误，可以使用一些数学编码方法，在数据接收时或传输过程中对比特错误进行检测和修复

   1. 谓“数学编码”通常指差错检测与纠正编码（Error Detection and Correction Codes），例如：
      - 奇偶校验（Parity Bit）
      - CRC（循环冗余校验）
      - 汉明码（Hamming Code）
      - Reed-Solomon 编码等
   2. 这些编码可以：
      - 在接收端识别是否发生了错误；
      - 某些还能直接修复少量错误（如 1~2 bit 错误）；
      - 在某些系统中，还可边传输边校验，例如使用 FEC（前向纠错）技术。

4. 这类任务（指轻微比特错误的处理，如CRC）通常由网络内部例行执行。当在包交换网络中发生更严重的损坏时，通常会对整个数据包进行重发。在电路交换或虚电路交换（如 X.25）网络中，重传往往发生在网络内部。对于那些要求数据严格按序且无差错传输的应用，这种方式可能效果良好；但也有一些应用并不需要这样的能力，也不希望承担（如建立连接和可能的重传延迟等）为实现可靠传输所带来的成本。

   1. 在 X.25 或类似的 VC-switched 网络 中：

      - 网络内维护连接状态；
      - 网络负责检测并重传错误数据；
      - 优点是对应用透明，保证了可靠性；
      - 缺点是成本高，如连接建立延迟、重传带来的延时、资源消耗。

      与之相对的，现代 TCP/IP 网络中的包交换策略：

      - 尽量让错误控制推给端系统（如 TCP 的端到端重传）；
      - 某些应用（如视频流、VoIP）甚至宁愿接受部分丢包，也不想承担重传延迟，因为实时性更重要。

5. 即使是一个可靠的文件传输应用，其实也并不真正关心文件数据块是以什么顺序传送的，只要最终能够确认所有数据块都无差错地传输到了，并且可以重新组装回原始的顺序即可。

   1. 这句话强调了一个很重要的点：
      - 传输顺序 vs. 结果完整性：
         某些应用（如文件传输）最终关注的是数据的完整和准确，并不要求传输过程中必须“按序到达”。
      - 重组由接收端完成：
         比如 FTP 等协议可以处理乱序到达的文件块，只要全部块都传完、无错误，就可以正确重组出原始文件。
      - 这与“流式应用”不同：
         视频播放、音频对话这类实时应用更在意数据顺序，而不是完全准确；而文件传输则相反。
   2. 有时可以牺牲传输顺序换取效率，而顺序控制可以交由应用或上层协议处理。

6. 尽力而为传输（best-effort delivery），这是与“可靠、有序传输”相对的一种网络服务模型。

   1. 作为一种替代于在网络中实现可靠、按序传输所带来的开销的方法，另一种被 Frame Relay 和 IP 协议采纳的服务类型是“尽力而为传输”（best-effort delivery）。
   2. 在这种方式下，网络不会投入太多精力去确保数据能够无差错、无遗漏地传输。某些类型的错误通常通过差错检测码或校验和来发现，比如那些会影响数据报传送方向的错误；但一旦检测到此类错误，出错的数据报就会被直接丢弃，不会采取进一步处理措施。

7. 如果尽力而为的传输成功，那么一个高速发送方可能会以超过接收方处理能力的速率产生数据。在基于尽力而为的 IP 网络中，限制发送方速率是通过在网络之外、通信系统更高层中的流量控制机制 flow control mechanisms 来实现的。

   1. 解决办法不是由 IP 层提供：IP 层不进行速率管理。

   2. IP层 = TCP/IP 模型中的 Internet Layer（网际层）

   3. “IP层”是一个术语上的简化表达，指的是 IP 协议所在的那一层。他负责

      ![image-20250510173349037](./assets/image-20250510173349037.png)

      1. 分配与管理 IP 地址；
      2. IP 数据报的封装与路由；
      3. 协议：IPv4、IPv6、ICMP、ARP（部分归于 link 层）

8. 这与端到端原则是一致的：TCP 位于终端主机中，负责速率控制。它也与命运共享原则相符：这种做法允许网络基础设施中的某些组件发生故障，而不会必然影响网络外部设备之间的通信能力（只要仍有某条通信路径保持可用）。

Design and Implementation

1. 尽管协议架构可能暗示某种实现方式，但它通常并不强制规定。因此，我们需要区分“协议架构”和“实现架构”：
   1. 协议架构定义了某一通信体系的概念性结构，
   2. 而实现架构则定义了如何将这些概念具体实现出来，通常是以软件的形式。
   3. “include a mandate” 是技术写作中常用的中性表达，表示某项规范或架构是否明确规定了必须执行的行为，同时保留语义的灵活性与客观性。这里没直接使用mandate作为动词就是处于这个原因
   4. “Consequently” 表示逻辑上的“因此、所以”，强调：前一句话的事实，直接导致了我们采取某个做法或观点的必要性。这里用它，要比`so,then`要更为正式
   5.  be rendered into existence 来描述implement architecture 将概念转化为实现的动作
2. 许多负责实现 ARPANET 协议的工程师都熟悉操作系统的软件结构。而一篇具有影响力的论文，描述了 “THE” 多道程序设计系统 [D68]，它主张使用一种分层结构，以此来应对验证大型软件实现的逻辑健全性Soundnesss与正确性Correctness的问题。
   1. 比较correctness和soundness的区别
      1. Correctness：你写出来的系统（代码）做了你想让它做的事情（行为符合规范）。 是否符合预期
      2. Soundness:  你证明这个系统没问题的方法是可靠的，不会证明一个实际上是错的东西为对。说得通
3. 最终，这促成了一种网络协议的设计哲学，即在实现（和设计）中引入多层结构。这种方法现在被称为分层（layering），并已成为实现协议族的常见方式。
   1. 网络协议之所以采用分层，是历史积累和工程实践共同推动的结果，它源于早期操作系统分层结构的成功经验**，**并最终内化为现代网络协议设计的核心哲学



layering

1. 采用分层结构后，每一层负责通信过程中的不同方面。分层设计的好处在于：它允许开发者将系统的不同部分**独立地进行演进和修改**，这些部分通常由**不同的人**，具备**不同领域的专业知识**来分别开发。

2. 协议分层中最常被提及的概念，基于一个名为“开放系统互联”（OSI）模型的标准 [Z80]，该标准由国际标准化组织（ISO）制定。

3. 尽管 OSI 模型认为，为了实现协议架构的模块化，七个逻辑层是理想的选择，但 TCP/IP 架构通常被认为由五层组成。在 1970 年代早期，人们曾围绕 OSI 模型与其前身——ARPANET 模型——各自的优劣展开了大量争论。

4. 尽管说 TCP/IP 最终“胜出”也许是公允的，但来自 ISO 协议族（即遵循 OSI 模型并由 ISO 标准化的一组协议）的一些理念，甚至整个协议，仍被采纳用于 TCP/IP 体系中。

5. OSI 七层模型

   1. 第1层：物理层（Physical Layer）——定义比特如何在物理介质上传输，如电压、接头、速率。代表技术有 Ethernet 1000BASE-T、V.92、SONET/SDH。

   2. 第2层：数据链路层（Data Link Layer）——负责同一链路内的帧传输、MAC地址、差错检测。典型协议有以太网、Wi-Fi、HDLC。

      1. 链路层（或称数据链路层）包含用于在共享同一通信介质的相邻节点之间建立连接的协议与方法。
      2. 有些链路层网络（例如 DSL）只连接两个相邻节点。
      3. 而当多个节点可以同时访问同一个共享网络时，这种网络被称为多路访问网络（multi-access network）。Wi-Fi 和以太网就是这种多路访问链路层网络的例子，需要特定协议来协调在任意时刻由哪一个站点访问共享介质。
      4. 我们将在第 3 章中讨论这些内容。
      5. 主要负责“点到点”或“点到多点”的直接相邻连接；

   3. 第3层：网络层（Network Layer）——负责多跳路径转发与逻辑寻址。代表协议有 IP、X.25、CLNP。

      1. 网络层（或称网际层）是我们非常关注的一层。
      2. 对于像 TCP/IP 这样的分组网络，它提供一种可互操作的数据包格式，可以在不同类型的链路层网络之间传递。
      3. 该层还包括一套用于主机的寻址机制，以及路由算法，用于决定数据包从一台机器发送到另一台机器时应当经过哪条路径。

   4. 第4层：传输层（Transport Layer）——提供端到端连接与可靠性，如TCP的重传、流量控制。常见协议有 TCP、UDP、TP4。

      1. 在第 3 层之上，我们可以看到一些协议（至少在理论上）只由终端主机实现，其中包括传输层。

      2. 这也是我们非常关注的一层，因为它在不同会话之间提供了一个数据传输通道，而且其复杂程度可能会很高，具体取决于它所提供的服务类型（例如，在可能丢包的分组网络中实现可靠传输）。

         1. “only by end hosts”：

            - 传输层协议（如 TCP、UDP）并不由路由器、中间设备处理，而是完全在通信双方的操作系统中实现；
            - 这体现了端到端原则（End-to-End Principle）。

         2. “provides a flow of data between sessions”：

            - 传输层是连接“应用层会话”与“网络层通信”的中介；
            - 它将应用的数据分段，并管理多个并发连接（如多个 HTTP 请求）；
            - 提供端对端的“数据流”语义（例如 TCP 提供一个可靠、有序、字节流接口）。

            “quite complex... depending on services”：

            - UDP 很简单，无连接、无确认、无重传；
            - TCP 很复杂，包括序列号、ACK、重传、流量控制、拥塞控制、窗口滑动等；
            - 如果还加上 TLS 加密，复杂度进一步上升。

   5. 第5层：会话层（Session Layer）——管理会话状态，如建立、维护、重启连接。代表协议有 X.225。

      1. 会话层表示应用程序之间正在进行的交互（例如，在 Web 登录会话中使用 cookie 的场景）。会话层协议可能提供的能力包括连接的建立与重启，以及检查点机制（即保存目前已完成的工作进度）。
      2. 管理长时间持续的应用交互状态；
      3. 功能包括：
         - 会话建立 / 维护 / 恢复；
         - 检查点（checkpointing）：断点续传、自动保存；
      4. 举例：
         - 登录状态维持（如 cookie、token）；
         - 远程桌面中断恢复；
         - 数据库连接池中的连接复用。

   6. 第6层：表示层（Presentation Layer）——处理数据格式转换、加密、压缩等。功能如字符集转换、TLS 加解密。

      1. 在会话层之上是表示层，它负责信息的格式转换和标准编码。
      2. 关注数据“语义”层面的兼容；
      3. 功能包括：
         - 数据格式转换（如 XML ↔ JSON、EBCDIC ↔ ASCII）；
         - 编解码（如 JPEG、MP3）；
         - 加解密（如 TLS 的数据加密）；
      4. 实际上大多数编解码行为都由应用实现，或通过库支持。

   7. 第7层：应用层（Application Layer）——面向用户的通信接口，支持实际业务交互。协议如 FTP、HTTP、SMTP、Skype。

      1. 应用通常会实现各自的应用层协议，这些协议也是用户最常接触到的。应用层协议种类繁多，程序员也在不断地发明新的协议。因此，应用层是创新最多、能力扩展最活跃的地方，新的功能大多在此层被开发和部署。
      2. 没有统一标准强制开发者使用某一套；例如：
         1. Web 浏览器使用 HTTP、HTTPS；
         2. 邮件客户端使用 SMTP、IMAP、POP3；
         3. 聊天应用可能使用 WebSocket、自定义 JSON 协议等。
      3. 最贴近用户，也最容易感知：
         - 用户操作的是应用界面，但其背后通信依赖的是应用层协议；
         - 例如用户点击“登录”，其实就是发出一个 HTTPS 请求（应用层 + 安全层）。
      4. 创新与扩展主要发生在应用层：
         - 原因是：无需修改内核或操作系统即可开发和部署；
         - 常见新协议：
           - REST、GraphQL（比传统 HTTP 更灵活）；
           - gRPC、QUIC（优化传输效率）；
           - Matrix（加密聊天）、ActivityPub（联邦社交）等。

   8. 正如我们将看到的，互联网协议栈并不包括正式的会话层或表示层协议，因此这些功能如果需要，通常由应用程序自行实现。

Multiplexing, Demultiplexing, and Encapsulation in Layered Implementations 

1. 分层架构的一大主要优势，是它天然具备协议复用（multiplexing）的能力。这种复用方式允许多个不同的协议在同一套基础设施上共存。它还允许同一协议的多个实例（例如多个连接）被同时使用，而不会相互混淆。

   1. protocol multiplexing（协议复用）：
      - 这里的复用指的是：多个高层协议可以共享同一个底层通信机制；
      - 典型例子：
        - IP 层通过 协议字段（Protocol field） 区分上层是 TCP、UDP 还是 ICMP；
        - TCP 通过 端口号 区分多个不同应用或连接；
        - HTTP/1.1 或 HTTP/2 可在一个 TCP 连接中复用多个请求。
   2. 同一协议的多实例（instantiations）：
      - 比如：
        - 一台设备可以同时建立多个 TCP 连接（每个用一个 4 元组标识）；
        - 一个浏览器可以同时访问多个网页服务器；
      - 协议设计中必须支持“上下文隔离”，避免混淆。
   3. “on the same infrastructure”：
      - 不需要为每个协议或服务建立一套新的物理或逻辑通道；
      - 网络只需要一套通用“承载层”，上层协议可以灵活叠加。
   4. 分层结构带来的最大工程好处之一，是复用与隔离的能力：不同协议可以共存，一个协议的多个连接也可以同时存在且互不干扰，这使网络既灵活又可扩展。

2. 

   

